<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FantasticMao&#39;s Blog</title>
    <link>/</link>
    <description>Recent content on FantasticMao&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 23 Nov 2016 21:42:50 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>从数据结构角度看索引</title>
      <link>/posts/%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Sun, 24 Feb 2019 13:50:18 +0800</pubDate>
      
      <guid>/posts/%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%B4%A2%E5%BC%95/</guid>
      <description>上周和团队内部的同事分享了一则关于 MySQL 索引相关的知识。这个分享主要是从数据结构角度出发，学习和分析 MySQL 索引相关的一些特性和原理。 演讲稿 浏览器内在线查看：从数据结构角度看索引.pdf
当前页内在线预览： {% pdf /images/从数据结构角度看索引/从数据结构角度看索引.pdf %}
 B-Tree 插入元素  B-Tree 删除元素  B-Tree 查找元素 </description>
    </item>
    
    <item>
      <title>GC 对性能的影响对比</title>
      <link>/posts/gc-%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Wed, 14 Nov 2018 10:21:22 +0800</pubDate>
      
      <guid>/posts/gc-%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%E5%AF%B9%E6%AF%94/</guid>
      <description>本篇文章记录一个普通 Web 应用在访问量逐渐增加的情况下，不同类型 GC 对应用性能影响的趋势对比。在比较应用性能时，仅以响应时间（Latency）和吞吐量（Throughput）为应用的性能指标。
 由于不同类型 GC 本该适用于不同类型的应用（例如 Serial GC 适合运行单核 CPU 机器上的小应用，G1 GC 适合运行大内存的应用），所以此次比较结果不能得出各个 GC 谁优谁劣的绝对结论。
  以响应时间为性能指标
 以吞吐量为性能指标
 比较测试结果，总结得出
 Serial GC 在不同强度的并发下，吞吐量和响应时间表现均为最差； Parallel GC 号称是吞吐量优先 GC，但表现却并没有比 CMS GC 和 G1 GC 好很多； 在并发强度逐渐增高的情况下，CMS GC 和 G1 GC 相比 Serial GC 和 Parallel GC 的响应时间表现更好； 在并发强度不高的情况下，CMS GC 相比 G1 GC 的吞吐量表现要稍微好一些。  </description>
    </item>
    
    <item>
      <title>Java 内存模型与线程</title>
      <link>/posts/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sun, 01 Jul 2018 19:16:50 +0800</pubDate>
      
      <guid>/posts/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>摘自《深入理解 Java 虚拟机》 第 12 章 Java 内存模型与线程。
并发处理的广泛应用是使得 Amdahl 定律 代替 Moore 定律 成为计算机性能发展源动力的根本原因，也是人类「压榨」计算机运算能力的最有力武器。 硬件的效率与一致性 计算机的大部分运算任务都不可能只靠处理器（CPU）计算就能完成。因为大部分情况下，处理器都需要与存储设备（内存）进行交互，例如读取数据、存储运算结果等。
由于计算的 CPU 与内存的运算速度存在几个数量级的差距，所以现代大部分计算机系统都加入了一层读写速度尽可能接近 CPU 运算速度的 高速缓存（Cache），用来作为 CPU 和内存的缓冲。这种缓冲的运行机制是：将 CPU 运算所需要使用到的数据复制到缓存中，让运算能快速进行；当运算结束之后再从缓冲同步回内存之中。通过这种方式，CPU 就无需等待对内存的缓慢读写了。
不过这种运行机制也引入了一个新的问题：缓存一致性（Cache Coherence）。当多个 CPU 的运算任务都涉及同一块内存区域时，将可能导致 CPU 的寄存器、高速缓存、内存中的数据不一致问题。为了解决内存一致性问题，需要各个 CPU 在访问内存时都遵循一致的协议，在读写数据时需要根据协议来进行操作，类似的协议有 MSI Protocol、MESI Protocol、MOSI Protocol、Firefly、Dragon Protocol 等。
内存模型（Memory Module） 一词可以理解为在特定的操作协议下，计算机对特定的内存或高速缓存进行读写访问的抽象过程。不同架构的物理机器可以拥有不同的内存模型，Java 虚拟机也拥有自己的内存模型。
除了增加高速缓存之外，为了使 CPU 内部的运算单元能尽可能地被充分利用，CPU 还会可能会对输入代码进行 乱序执行（Out-Of-Order Execution） 优化。CPU 会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与 CPU 的乱序执行优化类似，Java 虚拟机的即时编译（JIT）也有类似的指令重排序（Instruction Reorder）优化。
 Java 内存模型 Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Module） 来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</description>
    </item>
    
    <item>
      <title>Vim 常用命令</title>
      <link>/posts/vim-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sat, 31 Mar 2018 21:51:23 +0800</pubDate>
      
      <guid>/posts/vim-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>本篇文章记录我所理解和掌握的 Vim 常用命令。另外，对于新手推荐阅读附录中的 参考资料。 Normal 模式 移动光标    命令 描述     h、← 向左移动光标   j、↓ 向下移动光标   k、↑ 向上移动光标   l、→ 向右移动光标   Ctrl + b、PgUp 向上翻页   Ctrl + f、PgDn 向下翻页   Ctrl + u 向上翻半页   Ctrl + d 向下翻半页   0、Home 移动光标至当前行的第一个位置   $、End 移动光标至当前行的最后一个位置   ^ 移动光标至当前行的第一个 非 blank 字符 位置   g_ 移动光标至当前行的最后一个 非 blank 字符 位置   ${n}G 相当于 :${n}   gg 相当于 1G 和 :${1}   G 移动光标至当前文件的最后一行   f${char} 向右移动光标至下个 char 字符的位置   F${char} 向左移动光标至上个 char 字符的位置   t${char} 向右移动光标至下个 char 字符的前一个位置   T${char} 向左移动光标至上个 char 字符的前一个位置    复制、粘贴、删除    命令 描述     yy 复制当前行   y + 移动光标 复制光标移动过程中的内容   选中内容 + y 复制光标选中的内容   p 执行 a／向下，再粘贴剪贴板内容   P 执行 i／向上，再粘贴剪贴板内容   x 向右删除一个字符，相当于插入模式中的 fn + Delete   X 向左删除一个字符，相当于插入模式中的 Delete   dd 删除当前行，并把删除的内容保存至剪贴板中，相当于「剪切」功能   d + 移动光标 删除光标移动过程中的内容   选中内容 + d 删除光标选中的内容    搜索    命令 描述     / ${word} 向下搜索 word 关键字   ?</description>
    </item>
    
    <item>
      <title>二分查找的实现细节</title>
      <link>/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/</link>
      <pubDate>Sat, 10 Mar 2018 14:58:31 +0800</pubDate>
      
      <guid>/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/</guid>
      <description>最近留意到关于实现 二分查找算法（Binary Search Algorithm） 的一个小提醒，内容大致意思是：尽管算法思想很简单，但我们在正确实现二分查找的时候，仍需注意一下关于算法退出条件和中间值计算的相关细节。
本篇文章简单介绍二分查找算法，围绕相关的实现细节问题，做些浅显的分析。 简单介绍 在计算机科学中，二分查找也被称为折半查找、对数查找，是一种在有序数组中查找目标元素的搜索算法。
二分查找会将目标元素与数组中间元素进行比较，若不相等，则目标元素不存在的半段数组会被淘汰，并且查询会在目标元素存在的半段数组中继续进行，直到比较成功为止。如果查询以空数组为结束，则表示目标元素不存在。一次二分查找的具体过程可以参考下图（图片来源自维基百科）：
二分查找的最差时间复杂度是 𝑶(log 𝒏)，空间复杂度是 𝑶(1)。相比于最差时间复杂度为 𝑶(𝒏) 的 线性查找（Linear Search），二分查找执行更快、效率更高。相比于为快速查找量身定制的数据结构 哈希表（Hash Table），二分查找的限制更少、应用更广。
二分查找有许多不同的变种版本，例如 Fractional Cascading 加速了二分查找在多个数组中对相同数值的搜索速度，有效解决了计算机几何以及其它领域中的一系列搜索相关问题；Exponential Search 扩展了二分查找算法，使其可以应用于无界列表。
二分查找的算法思想也衍生出了许多其它数据结构和算法，例如 Binary Search Tree 和 B-Tree。
 初步实现 以 Java 语言为例，初步实现一个简单的二分查找算法，演示代码如下：
public int binarySearch(int[] arr, int low, int high, int key) { // 算法退出条件  if (low &amp;gt; high) { return -1; } // 计算本次查找的中间值  int mid = (low + high) / 2; // 二分查找的判断逻辑  if (arr[mid] &amp;lt; key) { return binarySearch(arr, mid + 1, high, key); } else if (arr[mid] &amp;gt; key) { return binarySearch(arr, low, mid - 1, key); } else { return mid; } } 依据文章开头的小提醒 review 上例代码，可以发现其中存在着的细节问题：</description>
    </item>
    
    <item>
      <title>设计模式概览</title>
      <link>/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/</link>
      <pubDate>Wed, 14 Feb 2018 23:33:47 +0800</pubDate>
      
      <guid>/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/</guid>
      <description>本篇文章记录我所理解和掌握的设计模式，及其在 JDK 和 Spring 中的实现。 创建型 Creational Patterns 抽象工厂模式 Abstract Factory Pattern 意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。Provide an interface for creating families of related or dependent objects without specifying their concrete classes.
参考：Wikipedia、java-design-patterns、菜鸟教程
实现：
 org.springframework.beans.factory.FactoryBean#getObject()  生成器模式 Builder Pattern 意图：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。Separate the construction of a complex object from its representation so that the same construction process can create different representations.
参考：Wikipedia、java-design-patterns、菜鸟教程
实现：
 java.lang.StringBuilder &amp;amp; java.lang.StringBuffer org.springframework.boot.web.client.RestTemplateBuilder org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder  工厂方法模式 Factory Method Pattern 意图：定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。Define an interface for creating an object, but let subclasses decide which class to instantiate.</description>
    </item>
    
    <item>
      <title>UDP 必知必会</title>
      <link>/posts/udp-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</link>
      <pubDate>Sat, 23 Dec 2017 15:39:28 +0800</pubDate>
      
      <guid>/posts/udp-%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</guid>
      <description>摘自《计算机网络》 第 5 章 传输层，并参考自维基百科与 RFC-768。协议概述 UDP（User Datagram Protocol，用户数据报协议）是 OSI 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠的数据传送服务，是 TCP/IP 协议族的核心成员之一，由 David P. Reed 于 1980 设计，并在 RFC-768 中正式定义。
UDP 使用最小协议机制的简单无连接通信模型，可以使分组交换的计算机在 IP 网络上使用数据报通信。它提供 checksum 字段用于保证数据完整性，提供 port number 字段用于区分源地址和目标地址不同功能的应用进程。UDP 适用于对错误校验和错误纠正要求不高的应用场景，如多媒体应用、IP 电话等等。UDP 在通讯时不需要像 TCP 一样进行握手，因此减少了网络通信的开销和发送数据之前的延迟，但它也是不可靠的传输协议，即不保证数据可靠的交付和时序。
UDP 只在 IP 的数据服务之上增加了很少的一点功能，其主要特点是：
 UDP 是无连接的，即发送数据之前不需要建立连接； UDP 不保证可靠交付，因此主机不需要维持复杂的连接状态； UDP 是面向报文的，发送方的 UDP 对应用层交下来的报文，即不合并也不拆封，在添加首部后就向下交付 IP 层； UDP 没有拥塞控制，因此网络拥塞不会使源主机的发送频率降低； UDP 支持一对一、一对多、多对一和多对多的网络通信； UDP 首部只占 8 个字节，相比于占 20 字节的 TCP 开销很小。   报文结构 报文格式： 首部字段： Source Port：可选字段，表示发送进程的端口，在需要对方回信时选用。缺省值为全 0； Destination Port：必选字段，表示接收进程的端口； Length：包含 header 和 data 的用户数据报文的长度，最小值是 8； Checksum：用于校验用户数据报文在传输过程中是否有错。</description>
    </item>
    
    <item>
      <title>设计原则</title>
      <link>/posts/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Wed, 04 Oct 2017 10:23:57 +0800</pubDate>
      
      <guid>/posts/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>摘自《写给大家看的设计书》第一部分 —— 设计原则。引言 以下是对基本设计原则的概述，每一个优秀的设计中都应用了这些设计原则。要记住，它们实际上是相互关联的，只应用某一个原则的情况很少。
 对比（Contrast） 对比的基本思想是，要避免页面上的元素太过相似。如果元素（字体、颜色、大小、线宽、形状、空间等）不相同，那就干脆让它们截然不同。要让页面引人注目，对比通常是最重要的一个因素。 重复（Repetition） 让设计中的视觉要素在整个作品中重复出现。可以重复颜色、形状、材质、空间关系、线宽、字体、大小和图片，等等。这样一来，既能增加条理性，还可以加强一致性。 对齐（Alignment） 任何元素都不能在页面上随意安放，每个元素都应当与页面上的另一个元素存在某种视觉联系。这样能建立一种清晰、精巧而且清爽的视觉效果。 亲密性（Proximity） 彼此相关的元素应当靠近，归组在一起。如果多个元素之间存在很近的亲密性，它们就会成为一个视觉单元，而不是多个孤立的项。这样有助于组织页面信息、减少混乱。   亲密性 如果一个设计中充斥着太多的内容，这个页面会显得杂乱无章，读者也无法从中很快看到所需的信息。Robin 亲密性原则是指： 将相关的元素组织在一起。
移动相关的元素项，使它们的物理位置相互靠近，将相关的元素项凝聚为一个组，而不是一堆彼此无关的片段；移动无关的元素项或组，使它们的物理位置相互分离，为读者提供一个直观的提示，使其可以马上了解页面的组织和内容。
就像实际生活中一样，亲密性意味着存在关联。如果把类似的元素组织为一个单元，马上会带来很多变化。首先，页面会变得更有条理。其次，你会更清楚地知道从哪里开始阅读，从哪里结束阅读。另外，空白（即字符之外的空间）也会变得更有组织。
亲密性原则不是说所有的元素都要靠近，其真正的含义是：如果某些元素在理解层面上存在关联，那么这些元素也应当在视觉层面上存在关联。除此之外，其它孤立的元素或元素组则不应该存在亲密性。物理位置的是否靠近，可以体现元素之间是否存在关联。
 对齐 设计新手往往很草率，只要页面上刚好有空间，就会把文本和图片放在那里，而全然不考虑页面上的其它元素。这样得到的页面会给人一种杂乱无章的感觉。Robin 对齐原则是指：任何元素都不能在页面上随意安放，每个元素都应当与页面上的另一个元素存在某种视觉联系。
如果页面上的一些元素是对齐的，这会得到一个更内聚的单元。即使对齐的元素的物理位置是彼此分离的，但它们之间也会有一条看不见的线把彼此联系在一起。尽管 亲密性原则 可能会分开某些元素，但对齐原则可以告诉读者，即使这些元素不靠近，它们任然是属于同一组的。
初学者通常采用居中对齐，居中对齐会创建一种更正式、更稳健的视觉效果，这种效果更为中规中矩，但通常也更乏味。这是一个误区，大多数精巧的设计通常都不会采用居中对齐。初学者需要从一开始就强制自己避免使用居中对齐。通过善用 亲密性原则，并结合明确的左对齐或右对齐，来改善设计的实现。
但并非是绝对不要使用居中对齐，仅是需要注意使用居中对齐时的效果。例如，大多数婚礼都很庄重、很正式，所以想用居中对齐设计结婚喜帖，完全可以在营造喜庆气氛的同时这么做。
在学习更多的设计原则之前，需要坚持一个原则：只使用一种对齐方式。在页面上只使用一种文本对齐，所有文本都左对齐，或右对齐，或居中对齐。不过，除非可以确保这些元素都能以某种方式对齐，才可以在一个页面上同时使用不同的对齐方式。（可惜不方便举例子，理解这段矛盾的话，请参照原书 P35）
 重复 Robin 重复原则指出：设计中的某些元素需要在整个作品中重复出现。重复的元素可能是一种粗字体、粗线条、某个项目符号、颜色、某种设计要素、格式、空间关系等等。
读者能看到的任何地方都可以作为重复的元素。为了实现重复，可以增加全新的元素，可以选择简单的元素并以多种不同的方式加以重复，甚至可以增加与页面主题没有任何联系的元素。只要确保重复行为看起来像是有意为之，而不是乱七八糟的就行。
重复原则可以将作品中的各部分连接在一起，从而统一并增强整个作品的视觉效果。重复不仅只对一页的作品有效，对多页的文档设计更为重要。
 对比 对比是增强页面视觉效果的最有效途径，也是在不同元素之间建立一种有组织的层次结构的最有效方法。Robin 对比原则指出：页面上的不同元素之间要有对比效果，以此达到吸引读者的对比效果。如果两个元素不完全相同，就应当使之不同，而且应当是截然不同。
对比不仅可以用来吸引眼球，还可以用来组织信息、清晰层级、在页面上指引读者，并制造焦点。可以采用多种方式产生对比，比如大字体与小字体的对比；典雅的旧式体与加粗的无衬线体产生对比；细线与粗线的对比；冷色与暖色的对比；平滑材质与粗糙材质的对比；水平元素与垂直元素的对比；间隔很宽的文本行与紧凑在一起的文本行形成对比；小图片与大图片的对比等等。
需要记住一个重要原则：想要实现有效的对比，对比就必须要强烈。千万不要畏畏缩缩。如果两个元素虽然不同，但是区别不大，这时候就不是对比了，而是冲突。不应该用 12 磅大小的字体与 14 磅大小的字体进行对比；也不要用 0.5 磅的线与 1 磅的线来对比；深棕色与黑色的对比也是不合适的。
将对比与其他原则：亲密性原则、对齐原则、重复原则 合理搭配使用，才会有更好的整体效果。设计页面时，只使用一种原则是很少的。
 总结 一个关于设计（同时也是生活）的更一般的指导原则是：不要畏畏缩缩
 不要害怕留有空白。 不要害怕设计是不对称的。 不要害怕把图片设置得太大或太小。 不要害怕把单词设置得非常大或非常小。  </description>
    </item>
    
    <item>
      <title>如何快速上手一个框架</title>
      <link>/posts/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E4%B8%80%E4%B8%AA%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 14 Sep 2017 01:10:06 +0800</pubDate>
      
      <guid>/posts/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E4%B8%80%E4%B8%AA%E6%A1%86%E6%9E%B6/</guid>
      <description>大多时候我们总是为寻求成熟可靠的方案，去选择一个框架，解决现有问题。比如使用 System.out.println() 打印日志很麻烦而且也不规范，于是我们使用 Log4j、Logback 等日志框架；请求的访问量很高，我们则使用 Redis、Memcached 缓存技术（这两个严格意义上不算框架，但情况类似）。
有时候也会觉得现有的代码太烂，或是其它原因，我们选用了新的框架替换之。比如抛弃了频发抛安全漏洞的 Struts，而使用 Spring MVC；抛弃了繁琐流程的 JDBC，而使用 ORM 框架。
开源潮流如火如荼，开源框架多如牛毛。在这个时代，我们应如何快速上手一个框架，这便是我今天要分享的 Topic —— 关于使用框架的方法论。 一 在我认为，适应或者说上手一个框架的第一个阶段是：了解框架背后涉及的专业知识。
使用 JSON 序列化框架，我们就需要知道 JSON 对象的定义和其序列化机制，如此调用 Jackson、Gson、FastJson 等系列框架的 API 才能明白原理。
使用 Web 框架，则需要知道 HTTP 协议，知道 HTTP 报文、Cookie - Session 机制、持久连接机制等等，了解这一系列之后，我们使用 Servlet、Spring MVC、Struts 或者包括其它语言的 Web 框架，才能得心顺手。
同理可得，当使用 Netty 网络编程框架，我们就需要知道必要的更底层的 TCP/IP 等网络知识，虽然我还没接触过。
未了解过框架涉及领域的专业知识，茫然调用框架提供的 API，是一件很冲动和白费力气的事情。
 二 第二个阶段是：开始使用框架，牛刀小试。
这个阶段主要是依靠零碎知识和搜索引擎的帮助，开始使用框架。这期间可能会遇到很多问题，包括对框架概念的不理解、对应用程序抛的异常束手无策等等。在这个阶段，每解决一个问题，都是一次自己能力的小提升。在这个充满挑战的阶段，建议在 IDE 上配置相关 Jar 包的源代码，并在调试程序阶段，通过阅读源代码和注释（开源框架的注释总是很详细的），来理解框架 API 层面提供的功能。这个阶段也可以为后续从点到面地阅读框架源代码做准备。
举个例子，在实践 Spring IoC 模块时候，起初可能会依靠各种比喻和解释来理解「依赖注入」这个概念，并且会生硬地参照着杂七杂八的 Demo，来编写一个 Spring 应用的代码。这便是我所说的使用框架的第二阶段。
 三 第三个阶段是：阅读经典书籍，参阅官方文档。</description>
    </item>
    
    <item>
      <title>jQuery API 小记</title>
      <link>/posts/jquery-api-%E5%B0%8F%E8%AE%B0/</link>
      <pubDate>Fri, 21 Apr 2017 15:44:01 +0800</pubDate>
      
      <guid>/posts/jquery-api-%E5%B0%8F%E8%AE%B0/</guid>
      <description>摘自《JavaScript 权威指南》第 19 章 jQuery 类库。
JavaScript 的核心 API 设计的很简单，但由于不同浏览器之间的严重不兼容，导致客户端的 API 过于复杂。使用 JavaScript 框架或工具类库能简化通用操作，能隐藏浏览器之间的差异，这让很多程序员在开发 Web 应用时变得更简单。撰写本书时，最流行和广泛采用的类库之一就是 jQuery。 jQuery 基础 jQuery 类库定义了一个全局函数：jQuery()。该函数使用频繁，因此在类库中还给它定义了一个快捷别名：$()。这是 jQuery 在全局命名空间中定义的唯一两个变量。
在 jQuery 类库中，最重要的方法是 jQuery()，也就是 $()。它的功能很强大，有 4 中不同的调用方式：
  传递 CSS 选择器字符串给 $()。当通过这种方式调用时，$() 返回当前文档中匹配该选择器的元素集；
  传递一个 Element、Document 或 Window 对象给 $()。在这种情况下，$() 只须简单地将 Element、Document、Window 对象封装成 jQuery 对象并返回；
  传递 HTML 文本字符串给 $()。在这种调用方式下 jQuery 会根据传入的文本创建好 HTML 元素并封装成 jQuery 对象返回；
  传入一个函数给 $()。此时，文档加载完毕且 DOM 可操作时，传入的函数将被调用。
jQuery(function () { // 文档加载完毕时调用  // 所有 jQuery 代码放在这里 });   传递 CSS 选择器字符串给 $()，它返回的 jQuery 对象表示匹配该选择器的元素集。jQuery 对象是类数组，它们拥有 length 属性和介于 0 - length - 1 之间的数值属性。这意味着可以使用标准的数组标识方括号来访问 jQuery 对象的内容。如果不想把数组标识用在 jQuery 对象上，可以使用 size() 来替代 length 属性，用 get() 来替代方括号索引。可以使用 toArray() 将 jQuery 对象转化为真实数组。</description>
    </item>
    
    <item>
      <title>MySQL 索引高性能策略</title>
      <link>/posts/mysql-%E7%B4%A2%E5%BC%95%E9%AB%98%E6%80%A7%E8%83%BD%E7%AD%96%E7%95%A5/</link>
      <pubDate>Fri, 03 Feb 2017 16:24:07 +0800</pubDate>
      
      <guid>/posts/mysql-%E7%B4%A2%E5%BC%95%E9%AB%98%E6%80%A7%E8%83%BD%E7%AD%96%E7%95%A5/</guid>
      <description>摘自《高性能 MySQL》第 5 章 创建高性能的索引。 索引基础 索引（在 MySQL 中也叫做键 key）是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键，尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载比较低时，不恰当的索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急剧下降。
理解 MySQL 中索引是如何工作的，最简单的方法就是去看看一本书的「索引」部分。如果想在一本书中找到某个特定主题，一般会先看书的「索引」，再找到对应的页码。在 MySQL 中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。
索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高几个数量级，「最优」的索引有时比「好的」索引性能要好两个数量级。
索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一个列的索引是大不相同的。
 索引的类型 索引有很多种类型，可以为不同的场景提供更好的性能。在 MySQL 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准，不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引，即使多个存储引擎支持同一种类型的索引，其底层实现也可能不同。
MySQL 逻辑架构可以参考下图（图片来源自 网络）:
B-Tree 索引 当人们谈论索引的时候，如果没有特别指明类型，多半说的是 B-Tree 索引，它使用 B-Tree 数据结构来存储数据。底层的存储引擎也可能使用不同的存储结构，例如 NDB 群集存储引擎内部实际上使用了 T-Tree 结构存储索引，InnoDB 则使用的是 B+Tree 数据结构。
存储引擎以不同的方式使用 B-Tree 索引，性能也各有不同、各有优劣。例如 MyISAM 使用前缀压缩技术使得索引更小，但 InnoDB 则按照原数据格式进行存储。再如 MyISAM 索引通过数据的物理位置引用被索引的行，而 InnoDB 则根据主键引用被索引的行。
B-Tree 数据结构和算法原理可以参考文章 MySQL 索引背后的数据结构及算法原理 。
B-Tree 通常意味着所有的值都是按顺序存储的，并且每一个叶子节点到根节点的距离相同。叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其它的节点。树的深度和表的大小直接相关。
B-Tree 索引能加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点中的值和需要查找的值，找到合适的指针进入下层子节点。这些指针实际上定义了子节点中值的上限和下限。最终存储引擎要么是找到对应的值，要么是得出该值的记录不存在。
B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。例如，在一个基于文本域的索引树上，按字母顺序连续传递的值进行查找是非常合适的。索引对多个值进行排序的依据是 CREATE TABLE 语句中定义索引时列的顺序。
假设有如下数据表：
CREATE TABLE People ( last_name VARCHAR(50) NOT NULL, first_name VARCHAR(50) NOT NULL, dob DATE NOT NULL, gender ENUM (&amp;#39;m&amp;#39;, &amp;#39;f&amp;#39;) NOT NULL, KEY (last_name, first_name, dob) ) B-Tree 索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找前面所述的索引对如下类型的查询有效：</description>
    </item>
    
    <item>
      <title>MySQL 数据类型优化</title>
      <link>/posts/mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/</link>
      <pubDate>Wed, 25 Jan 2017 12:20:03 +0800</pubDate>
      
      <guid>/posts/mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/</guid>
      <description>摘自《高性能 MySQL》第 4 章 Schema 与数据类型优化。良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计 schema，这往往需要权衡各种因素。例如，反范式的设计可以加快某些类型的查询，但同时可能使另一些类型的查询变慢。比如添加计数表和汇总表是一种很好的优化查询的方式，但这些表的维护成本可能会很高。MySQL 独有的特性和实现细节对性能的影响也很大。
 选择优化的数据类型 MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，都应遵从下面几个原则：
  更小的通常更好
一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为它们占用更少的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期也更少。
  简单就好
简单数据类型的操作通常需要更少的 CPU 周期。例如整型比字符串代价更低，因为字符集和校对规则使字符串比较比整型比较更复杂。建议使用 MySQL 内建的类型而不是字符串来存储日期时间，建议使用整型存储 IP 地址。
  尽量避免 NULL
通常情况下最好指定列为 NOT NULL，除非真的需要存储 NULL 值。如果查询中包含可为 NULL 的列，对 MySQL 来说更难优化，因为可为 NULL 的列使得索引、索引统计和值比较都更复杂。可能为 NULL 的列会使用更多的存储空间，在 MySQL 里也需要特殊处理。当可为 NULL 的列被索引时，每个索引记录需要一个额外的字节，在 MyISAM 里甚至还可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引。
  在为列选择数据类型时，第一步确定合适的大类型：数字、字符串、时间等，第二步选择具体类型。很多 MySQL 的数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同、需要的物理空间（磁盘和内存空间）不同。相同大类型的不同子类型数据有时也有一些特殊的行为和属性，如 DATETIME 和 TIMESTAMP。
 整数类型 可以使用这几种整型类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别使用 8、16、24、32、64 位存储空间，它们的存储的值的范围从 -2 ^ (N - 1) 到 2 ^ (N - 1) - 1，其中 N 是存储空间的位数。</description>
    </item>
    
    <item>
      <title>Java 泛型的擦除</title>
      <link>/posts/java-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%93%A6%E9%99%A4/</link>
      <pubDate>Mon, 02 Jan 2017 20:12:26 +0800</pubDate>
      
      <guid>/posts/java-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%93%A6%E9%99%A4/</guid>
      <description>本篇记录 Java 的一个残缺实现，确切地说是 Java SE5 为向后兼容而采取的折中实现 —— 泛型，记录内容包括基本语法、通配符和边界、泛型擦除。摘自《Java 编程思想》15 章。
 泛型简介 泛型程序设计是程序设计语言的一种风格或范式。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。
Java 泛型的参数只可以代表类，不能代表个别对象。由于 Java 泛型的类型参数之实际类型在编译时会被消除，所以无法在运行时得知其类型参数的类型，而且无法直接使用基本值类型作为泛型类型参数。Java 编译程序在编译泛型时会自动加入类型转换的编码，故运行速度不会因为使用泛型而加快。—— 摘自 维基百科
一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。—— 摘自 菜鸟教程
我的简单理解：泛型在编程语言概念中是顾名思义的 泛化的类型，而在 Java 的实现中则是一个为了 参数化类型 的语法。它可以使我们编写更健壮更抽象的 Java 代码，但同时它因为存在缺陷而经常被人诟病。
 基本语法 泛型类 定义泛型类时，需在类名后添加一个尖括号包裹的 参数类型，然后在实例化类时，需要使用 具体类型 替换 参数类型。在代码中 参数类型 代表的就是类实例化时的 具体类型，如下是一个泛型类：
public class Generic&amp;lt;T&amp;gt; { private T t; public T getT() { return t; } public void setT(T t) { this.t = t; } } 泛型接口 同上，泛型接口的定义与泛型类并没什么区别。
泛型方法 泛型类／接口对类型的泛化应用于整个类之上，而泛型方法则仅限于当前方法。《Java 编程思想》书中提供了一个编写泛型代码的基本原则：无论何时，只要你能做到，你就应该尽量使用泛型方法。这也意味着我们应该尽可能地缩小类型泛化的应用范围。</description>
    </item>
    
    <item>
      <title>关于</title>
      <link>/about/</link>
      <pubDate>Wed, 23 Nov 2016 21:42:50 +0800</pubDate>
      
      <guid>/about/</guid>
      <description>我，一个 95 年、黑头发、戴眼镜的小伙子。
2016 年参加工作，以 Java 谋生，也对 JavaScript、Python、Golang、Shell Script 感兴趣，想要学习网络编程、分布式架构、云原生领域的技术知识，坐标浙江杭州。
讨论技术可以通过文章底部 Disqus 评论，或者通过首页的社交链接与我联系，随时欢迎 :)</description>
    </item>
    
  </channel>
</rss>