<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on FantasticMao&#39;s Blog</title>
    <link>https://blog.fantasticmao.cn/tags/java/</link>
    <description>Recent content in Java on FantasticMao&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 01 Jul 2018 19:16:50 +0800</lastBuildDate>
    
	<atom:link href="https://blog.fantasticmao.cn/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java 内存模型与线程</title>
      <link>https://blog.fantasticmao.cn/posts/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sun, 01 Jul 2018 19:16:50 +0800</pubDate>
      
      <guid>https://blog.fantasticmao.cn/posts/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>摘自《深入理解 Java 虚拟机》 第 12 章 Java 内存模型与线程。
并发处理的广泛应用是使得 Amdahl 定律 代替 Moore 定律 成为计算机性能发展源动力的根本原因，也是人类「压榨」计算机运算能力的最有力武器。 硬件的效率与一致性 计算机的大部分运算任务都不可能只靠处理器（CPU）计算就能完成。因为大部分情况下，处理器都需要与存储设备（内存）进行交互，例如读取数据、存储运算结果等。
由于计算的 CPU 与内存的运算速度存在几个数量级的差距，所以现代大部分计算机系统都加入了一层读写速度尽可能接近 CPU 运算速度的 高速缓存（Cache），用来作为 CPU 和内存的缓冲。这种缓冲的运行机制是：将 CPU 运算所需要使用到的数据复制到缓存中，让运算能快速进行；当运算结束之后再从缓冲同步回内存之中。通过这种方式，CPU 就无需等待对内存的缓慢读写了。
不过这种运行机制也引入了一个新的问题：缓存一致性（Cache Coherence）。当多个 CPU 的运算任务都涉及同一块内存区域时，将可能导致 CPU 的寄存器、高速缓存、内存中的数据不一致问题。为了解决内存一致性问题，需要各个 CPU 在访问内存时都遵循一致的协议，在读写数据时需要根据协议来进行操作，类似的协议有 MSI Protocol、MESI Protocol、MOSI Protocol、Firefly、Dragon Protocol 等。
内存模型（Memory Module） 一词可以理解为在特定的操作协议下，计算机对特定的内存或高速缓存进行读写访问的抽象过程。不同架构的物理机器可以拥有不同的内存模型，Java 虚拟机也拥有自己的内存模型。
除了增加高速缓存之外，为了使 CPU 内部的运算单元能尽可能地被充分利用，CPU 还会可能会对输入代码进行 乱序执行（Out-Of-Order Execution） 优化。CPU 会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与 CPU 的乱序执行优化类似，Java 虚拟机的即时编译（JIT）也有类似的指令重排序（Instruction Reorder）优化。
 Java 内存模型 Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Module） 来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</description>
    </item>
    
    <item>
      <title>设计模式概览</title>
      <link>https://blog.fantasticmao.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/</link>
      <pubDate>Wed, 14 Feb 2018 23:33:47 +0800</pubDate>
      
      <guid>https://blog.fantasticmao.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%A7%88/</guid>
      <description>本篇文章记录我所理解和掌握的设计模式，及其在 JDK 和 Spring 中的实现。 创建型 Creational Patterns 抽象工厂模式 Abstract Factory Pattern 意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。Provide an interface for creating families of related or dependent objects without specifying their concrete classes.
参考：Wikipedia、java-design-patterns、菜鸟教程
实现：
 org.springframework.beans.factory.FactoryBean#getObject()  生成器模式 Builder Pattern 意图：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。Separate the construction of a complex object from its representation so that the same construction process can create different representations.
参考：Wikipedia、java-design-patterns、菜鸟教程
实现：
 java.lang.StringBuilder &amp;amp; java.lang.StringBuffer org.springframework.boot.web.client.RestTemplateBuilder org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder  工厂方法模式 Factory Method Pattern 意图：定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。Define an interface for creating an object, but let subclasses decide which class to instantiate.</description>
    </item>
    
    <item>
      <title>如何快速上手一个框架</title>
      <link>https://blog.fantasticmao.cn/posts/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E4%B8%80%E4%B8%AA%E6%A1%86%E6%9E%B6/</link>
      <pubDate>Thu, 14 Sep 2017 01:10:06 +0800</pubDate>
      
      <guid>https://blog.fantasticmao.cn/posts/%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E4%B8%80%E4%B8%AA%E6%A1%86%E6%9E%B6/</guid>
      <description>大多时候我们总是为寻求成熟可靠的方案，去选择一个框架，解决现有问题。比如使用 System.out.println() 打印日志很麻烦而且也不规范，于是我们使用 Log4j、Logback 等日志框架；请求的访问量很高，我们则使用 Redis、Memcached 缓存技术（这两个严格意义上不算框架，但情况类似）。
有时候也会觉得现有的代码太烂，或是其它原因，我们选用了新的框架替换之。比如抛弃了频发抛安全漏洞的 Struts，而使用 Spring MVC；抛弃了繁琐流程的 JDBC，而使用 ORM 框架。
开源潮流如火如荼，开源框架多如牛毛。在这个时代，我们应如何快速上手一个框架，这便是我今天要分享的 Topic —— 关于使用框架的方法论。 一 在我认为，适应或者说上手一个框架的第一个阶段是：了解框架背后涉及的专业知识。
使用 JSON 序列化框架，我们就需要知道 JSON 对象的定义和其序列化机制，如此调用 Jackson、Gson、FastJson 等系列框架的 API 才能明白原理。
使用 Web 框架，则需要知道 HTTP 协议，知道 HTTP 报文、Cookie - Session 机制、持久连接机制等等，了解这一系列之后，我们使用 Servlet、Spring MVC、Struts 或者包括其它语言的 Web 框架，才能得心顺手。
同理可得，当使用 Netty 网络编程框架，我们就需要知道必要的更底层的 TCP/IP 等网络知识，虽然我还没接触过。
未了解过框架涉及领域的专业知识，茫然调用框架提供的 API，是一件很冲动和白费力气的事情。
 二 第二个阶段是：开始使用框架，牛刀小试。
这个阶段主要是依靠零碎知识和搜索引擎的帮助，开始使用框架。这期间可能会遇到很多问题，包括对框架概念的不理解、对应用程序抛的异常束手无策等等。在这个阶段，每解决一个问题，都是一次自己能力的小提升。在这个充满挑战的阶段，建议在 IDE 上配置相关 Jar 包的源代码，并在调试程序阶段，通过阅读源代码和注释（开源框架的注释总是很详细的），来理解框架 API 层面提供的功能。这个阶段也可以为后续从点到面地阅读框架源代码做准备。
举个例子，在实践 Spring IoC 模块时候，起初可能会依靠各种比喻和解释来理解「依赖注入」这个概念，并且会生硬地参照着杂七杂八的 Demo，来编写一个 Spring 应用的代码。这便是我所说的使用框架的第二阶段。
 三 第三个阶段是：阅读经典书籍，参阅官方文档。</description>
    </item>
    
    <item>
      <title>Java 泛型的擦除</title>
      <link>https://blog.fantasticmao.cn/posts/java-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%93%A6%E9%99%A4/</link>
      <pubDate>Mon, 02 Jan 2017 20:12:26 +0800</pubDate>
      
      <guid>https://blog.fantasticmao.cn/posts/java-%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%93%A6%E9%99%A4/</guid>
      <description>本篇记录 Java 的一个残缺实现，确切地说是 Java SE5 为向后兼容而采取的折中实现 —— 泛型，记录内容包括基本语法、通配符和边界、泛型擦除。摘自《Java 编程思想》15 章。
 泛型简介 泛型程序设计是程序设计语言的一种风格或范式。泛型允许程序员在强类型程序设计语言中编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。
Java 泛型的参数只可以代表类，不能代表个别对象。由于 Java 泛型的类型参数之实际类型在编译时会被消除，所以无法在运行时得知其类型参数的类型，而且无法直接使用基本值类型作为泛型类型参数。Java 编译程序在编译泛型时会自动加入类型转换的编码，故运行速度不会因为使用泛型而加快。—— 摘自 维基百科
一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。—— 摘自 菜鸟教程
我的简单理解：泛型在编程语言概念中是顾名思义的 泛化的类型，而在 Java 的实现中则是一个为了 参数化类型 的语法。它可以使我们编写更健壮更抽象的 Java 代码，但同时它因为存在缺陷而经常被人诟病。
 基本语法 泛型类 定义泛型类时，需在类名后添加一个尖括号包裹的 参数类型，然后在实例化类时，需要使用 具体类型 替换 参数类型。在代码中 参数类型 代表的就是类实例化时的 具体类型，如下是一个泛型类：
public class Generic&amp;lt;T&amp;gt; { private T t; public T getT() { return t; } public void setT(T t) { this.t = t; } } 泛型接口 同上，泛型接口的定义与泛型类并没什么区别。
泛型方法 泛型类／接口对类型的泛化应用于整个类之上，而泛型方法则仅限于当前方法。《Java 编程思想》书中提供了一个编写泛型代码的基本原则：无论何时，只要你能做到，你就应该尽量使用泛型方法。这也意味着我们应该尽可能地缩小类型泛化的应用范围。</description>
    </item>
    
  </channel>
</rss>