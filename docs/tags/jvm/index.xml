<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JVM on FantasticMao&#39;s Blog</title>
    <link>/tags/jvm/</link>
    <description>Recent content in JVM on FantasticMao&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 14 Nov 2018 10:21:22 +0800</lastBuildDate>
    
	<atom:link href="/tags/jvm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>GC 对性能的影响对比</title>
      <link>/posts/gc-%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Wed, 14 Nov 2018 10:21:22 +0800</pubDate>
      
      <guid>/posts/gc-%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D%E5%AF%B9%E6%AF%94/</guid>
      <description>本篇文章记录一个普通 Web 应用在访问量逐渐增加的情况下，不同类型 GC 对应用性能影响的趋势对比。在比较应用性能时，仅以响应时间（Latency）和吞吐量（Throughput）为应用的性能指标。
由于不同类型 GC 本该适用于不同类型的应用（例如 Serial GC 适合运行单核 CPU 机器上的小应用，G1 GC 适合运行大内存的应用），所以此次比较结果不能得出各个 GC 谁优谁劣的绝对结论。
 以响应时间为性能指标  以吞吐量为性能指标  比较测试结果，总结得出  Serial GC 在不同强度的并发下，吞吐量和响应时间表现均为最差； Parallel GC 号称是吞吐量优先 GC，但表现却并没有比 CMS GC 和 G1 GC 好很多； 在并发强度逐渐增高的情况下，CMS GC 和 G1 GC 相比 Serial GC 和 Parallel GC 的响应时间表现更好； 在并发强度不高的情况下，CMS GC 相比 G1 GC 的吞吐量表现要稍微好一些。  </description>
    </item>
    
    <item>
      <title>Java 内存模型与线程</title>
      <link>/posts/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sun, 01 Jul 2018 19:16:50 +0800</pubDate>
      
      <guid>/posts/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid>
      <description>摘自《深入理解 Java 虚拟机》 第 12 章 Java 内存模型与线程。
并发处理的广泛应用是使得 Amdahl 定律 代替 Moore 定律 成为计算机性能发展源动力的根本原因，也是人类「压榨」计算机运算能力的最有力武器。 硬件的效率与一致性 计算机的大部分运算任务都不可能只靠处理器（CPU）计算就能完成。因为大部分情况下，处理器都需要与存储设备（内存）进行交互，例如读取数据、存储运算结果等。
由于计算的 CPU 与内存的运算速度存在几个数量级的差距，所以现代大部分计算机系统都加入了一层读写速度尽可能接近 CPU 运算速度的 高速缓存（Cache），用来作为 CPU 和内存的缓冲。这种缓冲的运行机制是：将 CPU 运算所需要使用到的数据复制到缓存中，让运算能快速进行；当运算结束之后再从缓冲同步回内存之中。通过这种方式，CPU 就无需等待对内存的缓慢读写了。
不过这种运行机制也引入了一个新的问题：缓存一致性（Cache Coherence）。当多个 CPU 的运算任务都涉及同一块内存区域时，将可能导致 CPU 的寄存器、高速缓存、内存中的数据不一致问题。为了解决内存一致性问题，需要各个 CPU 在访问内存时都遵循一致的协议，在读写数据时需要根据协议来进行操作，类似的协议有 MSI Protocol、MESI Protocol、MOSI Protocol、Firefly、Dragon Protocol 等。
内存模型（Memory Module） 一词可以理解为在特定的操作协议下，计算机对特定的内存或高速缓存进行读写访问的抽象过程。不同架构的物理机器可以拥有不同的内存模型，Java 虚拟机也拥有自己的内存模型。
除了增加高速缓存之外，为了使 CPU 内部的运算单元能尽可能地被充分利用，CPU 还会可能会对输入代码进行 乱序执行（Out-Of-Order Execution） 优化。CPU 会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致。因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与 CPU 的乱序执行优化类似，Java 虚拟机的即时编译（JIT）也有类似的指令重排序（Instruction Reorder）优化。
 Java 内存模型 Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Module） 来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</description>
    </item>
    
  </channel>
</rss>