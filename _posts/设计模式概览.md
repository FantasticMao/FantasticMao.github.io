---
title: 设计模式概览
date: 2018-02-14 23:33:47
categories: 编程
tags:
---
本篇文章记录我所理解和掌握的设计模式。<!-- more -->

Design patterns are formalized best practices that the programmer can use to solve common problems when designing an application or system.

Design patterns can speed up the development process by providing tested, proven development paradigms.

Reusing design patterns helps to prevent subtle issues that can cause major problems, and it also improves code readability for coders and architects who are familiar with the patterns.

---

# 创建型 Creational Patterns
名称 | 描述 | 实现
--- | --- | ---
抽象工厂模式（Abstract Factory Pattern） | 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/abstract-factory)、[链接2](http://www.runoob.com/design-pattern/abstract-factory-pattern.html) | 待续
工厂方法模式（Factory Method Pattern） | 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/factory-method)、[链接2](http://www.runoob.com/design-pattern/factory-pattern.html) | java.lang.Object#toString()<br>java.lang.Boolean#valueOf()<br>java.lang.Class#newInstance()<br>java.lang.Class#forName()<br>java.nio.charset.Charset#forName()<br>java.lang.reflect.Proxy#newProxyInstance()
生成器模式（Builder Pattern） | 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/builder)、[链接2](http://www.runoob.com/design-pattern/builder-pattern.html) | java.lang.StringBuilder<br>java.lang.StringBuffer<br>org.springframework.boot.web.client.RestTemplateBuilder<br>org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder
对象池模式（Object Pool Pattern） | <br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/object-pool) | java.lang.Integer in JVM<br>DataSource Poll
单例模式（Singleton Pattern） | 保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/singleton)、[链接2](http://www.runoob.com/design-pattern/singleton-pattern.html) | java.lang.Runtime#getRuntime()

---

# 结构型 Structural Patterns
名称 | 描述 | 实现
--- | --- | ---
适配器模式（Adapter Pattern） | 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/adapter)、[链接2](http://www.runoob.com/design-pattern/adapter-pattern.html) | java.io.InputStreamReader<br>java.io.OutputStreamWriter<br>java.util.Collections#enumeration()<br>java.util.Collections#list()<br>java.util.Arrays#asList()
装饰器模式（Decorator Pattern） | 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/decorator)、[链接2](http://www.runoob.com/design-pattern/decorator-pattern.html) | java.io.BufferedInputStream<br>java.io.DataInputStream<br>java.util.Collections#synchronizedXXX()<br>java.util.Collections#unmodifiableXXX()
代理模式（Proxy Pattern） | 为其他对象提供一种代理以控制对这个对象的访问。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/proxy)、[链接2](http://www.runoob.com/design-pattern/proxy-pattern.html) | java.lang.reflect.Proxy<br>org.springframework.aop.framework.AopProxy
---

# 行为型 Behavioral Patterns

名称 | 描述 | 实现
--- | --- | ---
责任链模式（Chain-Of-Responsibility Pattern） | 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/chain)、[链接2](http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html) | java.util.logging.Logger#log()<br>javax.servlet.Filter#doFilter()<br>org.springframework.web.servlet.HandlerInterceptor
迭代器模式（Iterator Pattern） | 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/iterator)、[链接2](http://www.runoob.com/design-pattern/iterator-pattern.html) | java.util.Iterator<br>java.util.Enumeration
观察者模式（Observer Pattern） | 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/observer)、[链接2](http://www.runoob.com/design-pattern/observer-pattern.html) | java.util.Observer & java.util.Observable<br>org.springframework.context.ApplicationListener & org.springframework.context.ApplicationEvent
策略模式（Strategy Pattern） | 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/strategy)、[链接2](http://www.runoob.com/design-pattern/strategy-pattern.html) | java.lang.Comparable#compareTo()<br>org.springframework.web.accept.ContentNegotiationStrategy#resolveMediaTypes()
模板方法模式（Template Method Pattern） | 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/template-method)、[链接2](http://www.runoob.com/design-pattern/template-pattern.html) | org.springframework.context.support.AbstractApplicationContext#refresh()
访问者模式（Visitor Pattern） | 主要将数据结构与数据操作分离。<br>参考：[链接1](https://github.com/iluwatar/java-design-patterns/tree/master/visitor)、[链接2](http://www.runoob.com/design-pattern/visitor-pattern.html) | 待续
