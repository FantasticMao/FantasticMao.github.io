---
title: 设计模式概览
date: 2018-02-14 23:33:47
categories: 编程
tags:
---
本篇文章记录我所理解和掌握的设计模式，及其在 JDK 和 Spring 中的实现。<!-- more -->

---

# 创建型 Creational Patterns

## 抽象工厂模式 Abstract Factory Pattern
意图：Provide an interface for creating families of related or dependent objects without specifying their concrete classes. 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Abstract_factory_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/abstract-factory)、[菜鸟教程](http://www.runoob.com/design-pattern/abstract-factory-pattern.html)
实现：待续

## 工厂方法模式 Factory Method Pattern
意图：Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Factory_method_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/factory-method)、[菜鸟教程](http://www.runoob.com/design-pattern/factory-pattern.html)
实现：
- java.lang.Object#toString()
- java.lang.Boolean#valueOf() & java.lang.Integer#valueOf()
- java.lang.Class#newInstance() & java.lang.reflect.Proxy#newProxyInstance()
- java.lang.Class#forName() & java.nio.charset.Charset#forName()

## 生成器模式 Builder Pattern
意图：Separate the construction of a complex object from its representation so that the same construction process can create different representations. 将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Builder_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/builder)、[菜鸟教程](http://www.runoob.com/design-pattern/builder-pattern.html)
实现：
- java.lang.StringBuilder & java.lang.StringBuffer
- org.springframework.boot.web.client.RestTemplateBuilder
- org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder

## 对象池模式 Object Pool Pattern
意图：When objects are expensive to create and they are needed only for short periods of time it is advantageous to utilize the Object Pool pattern. The Object Pool provides a cache for instantiated objects tracking which ones are in use and which are available.
参考：[Wikipedia](https://en.wikipedia.org/wiki/Object_pool_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/object-pool)
实现：
- java.lang.Integer in JVM
- DataSource Poll

## 单例模式 Singleton Pattern
意图：Ensure a class only has one instance, and provide a global point of access to it. 保证一个类仅有一个实例，并提供一个访问它的全局访问点。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Singleton_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/singleton)、[菜鸟教程](http://www.runoob.com/design-pattern/singleton-pattern.html)
实现：
- java.lang.Runtime#getRuntime()

---

# 结构型 Structural Patterns

## 适配器模式 Adapter Pattern
意图：Convert the interface of a class into another interface the clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces. 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Adapter_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/adapter)、[菜鸟教程](http://www.runoob.com/design-pattern/adapter-pattern.html)
实现：
- java.util.Arrays#asList()
- java.io.InputStreamReader & java.io.OutputStreamWriter
- java.util.Collections#enumeration() & java.util.Collections#list()

## 装饰器模式 Decorator Pattern
意图：Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality. 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Decorator_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/decorator)、[菜鸟教程](http://www.runoob.com/design-pattern/decorator-pattern.html)
实现：
- java.io.BufferedInputStream & java.io.DataInputStream
- java.util.Collections#synchronizedXXX()& java.util.Collections#unmodifiableXXX()

## 代理模式 Proxy Pattern
意图：Provide a surrogate or placeholder for another object to control access to it. 为其他对象提供一种代理以控制对这个对象的访问。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Proxy_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/proxy)、[菜鸟教程](http://www.runoob.com/design-pattern/proxy-pattern.html)
实现：
- java.lang.reflect.Proxy
- org.springframework.aop.framework.AopProxy

---

# 行为型 Behavioral Patterns

## 责任链模式 Chain-Of-Responsibility Pattern
意图：Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it. 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/chain)、[菜鸟教程](http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html)
实现：
- java.util.logging.Logger#log()
- javax.servlet.Filter#doFilter()
- org.springframework.web.servlet.HandlerInterceptor

## 迭代器模式 Iterator Pattern
意图：Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation. 提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Iterator_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/iterator)、[菜鸟教程](http://www.runoob.com/design-pattern/iterator-pattern.html)
实现：
- java.util.Iterator
- java.util.Enumeration

## 观察者模式 Observer Pattern
意图：Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Observer_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/observer)、[菜鸟教程](http://www.runoob.com/design-pattern/observer-pattern.html)
实现：
- java.util.Observer & java.util.Observable
- org.springframework.context.ApplicationListener <br>& org.springframework.context.ApplicationEvent

## 策略模式 Strategy Pattern
意图：Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it. 定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Strategy_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/strategy)、[菜鸟教程](http://www.runoob.com/design-pattern/strategy-pattern.html)
实现：
- java.lang.Comparable#compareTo()
- org.springframework.web.accept.ContentNegotiationStrategy#resolveMediaTypes()

## 模板方法模式 Template Method Pattern
意图：Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure. 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Template_method_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/template-method)、[菜鸟教程](http://www.runoob.com/design-pattern/template-pattern.html)
实现：
- org.springframework.context.support.AbstractApplicationContext#refresh()

## 访问者模式 Visitor Pattern
意图：Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates. 主要将数据结构与数据操作分离。
参考：[Wikipedia](https://en.wikipedia.org/wiki/Visitor_pattern)、[java-design-patterns](https://github.com/iluwatar/java-design-patterns/tree/master/visitor)、[菜鸟教程](http://www.runoob.com/design-pattern/visitor-pattern.html)
实现：
- org.springframework.beans.factory.config.BeanDefinitionVisitor
