---
title: MySQL 索引高性能策略
date: 2017-02-03 16:24:07
categories: 数据库
tags: MySQL
---
摘自《高性能 MySQL》第 5 章 创建高性能的索引。

B-Tree 索引、聚簇索引的实现可参考：[http://blog.codinglabs.org/articles/theory-of-mysql-index.html](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)<!-- more -->

## 索引基础
索引（在 MySQL 中也叫做键 key）是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。「最优」的索引有时比「好的」索引性能要好两个数量级。

索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能高效地使用最左前缀列，创建一个包含两个列的索引，和创建两个只包含一个列的索引是大不相同的。

---

## 索引的类型
在 MySQL 中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。

### B-Tree 索引
当人们谈论索引的时候，如果没有特别指明类型，多半说的是 B-Tree 索引，它使用 B-Tree 数据结构来存储数据。不过底层的存储引擎也可能使用不同的存储结构，例如 NDB 群集存储引擎内部实际上使用了 T-Tree 结构存储索引；InnoDB 则使用的是 B+Tree。

存储引擎以不同的方式使用 B-Tree 索引，性能也各有不同，各有优劣。例如 MyISAM 使用前缀压缩技术使得索引更小，但 InnoDB 则按照原数据格式进行存储。

B-Tree 通常意味着所有的值都是按顺序存储的，并且每一个叶子节点到根节点的距离相同。

**B-Tree 索引能加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点中的值和需要查找的值，找到合适的指针进入下层子节点。这些指针实际上定义了子节点中值的上限和下限。最终存储引擎要么是找到对应的值，要么是得出该值的记录不存在。**

叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其它的节点。数的深度和表的大小直接相关。

B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据。例如，在一个基于文本域的索引树上，按字母顺序连续传递的值进行查找是非常合适的。索引对多个值进行排序的依据是 CREATE TABLE 语句中定义索引时列的顺序。

假设有如下数据表：
```sql
CREATE TABLE People (
  last_name  VARCHAR(50)     NOT NULL,
  first_name VARCHAR(50)     NOT NULL,
  dob        DATE            NOT NULL,
  gender     ENUM ('m', 'f') NOT NULL,
  KEY (last_name, first_name, dob)
)
```

B-Tree 索引适用于全键值、键值范围或键前缀查找。其中键前缀查找只适用于根据最左前缀的查找前面所述的索引对如下类型的查询有效：

* *全值匹配* ：全值匹配指的是和索引中的所有列进行匹配，如 `... WHERE last_name = 'Allen' AND first_name = 'Cuba' AND dob = '1960-01-01'`。
* *匹配最左前缀* ：只使用索引的第一列，如 `... WHERE last_name = 'Allen'`。
* *匹配列前缀* ：匹配索引第一列值的开头部分，如 `... WHERE last_name LIKE 'A%'`。
* *匹配范围值* ：范围匹配索引第一列值，如 `... WHERE last_name BETWEEN 'Allen' AND 'Barry'`。
* *精确匹配某一列并范围匹配另一列* ：精确匹配索引第一列值，并范围匹配第二列值，如 `... WHERE last_name = 'Allen' AND first_name LIKE 'C%'`。
* *只访问索引的查询* ：只访问索引数据，如 `SELECT last_name, first_name FROM People WHERE last_name = 'Allen'`。这种情况叫做 [覆盖索引](#覆盖索引)，即只须访问索引，而无须访问数据行。

**因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于 ORDER BY 操作。** 一般来说，如果 B-Tree 可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以如果 ORDER BY 子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。

以下是一些关于 B-Tree 索引的限制：
* 如果不是按照索引的最左列开始查找，则无法使用索引，如 `... WHERE first_name = 'Cuba'`。
* 不能跳过索引中的列，如 `... WHERE last_name = 'Allen' AND dob = '1960-01-01'`。
* 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查询，如 `... WHERE last_name = 'Allen' AND first_name = 'C%' AND dob = '1960-01-01'`，此时只能使用前两列索引。

索引列的顺序至关重要，这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。

### 哈希索引
**哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。**对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向行数据的指针。

在 MySQL 中，只有 Memory 引擎显式支持哈希索引。因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。然而哈希索引也有它的限制：
* 哈希索引只包含哈希值和行指针，而不存储字段，所以不能使用 [覆盖索引](#覆盖索引)。
* 哈希索引并不是按照索引值顺序存储的，所以也就无法用于排序。
* 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。
* 哈希索引只支持等值比较，包括 =、IN()、<=>。
* 访问哈希索引的数据非常快，除非有很多哈希冲突。如果哈希冲突很多的话，一些索引维护操作的代价也会很高。

InnoDB 引擎有一个特殊的功能叫做「自适应哈希索引」。当 InnoDB 注意到某些索引值被使用得非常频繁时，它会在内存中基于 B-Tree 索引之上再创建一个哈希索引。

### 空间数据索引（R-Tree）
MyISAM 存储引擎支持空间索引。和 B-Tree 索引不同，空间索引无须前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 相关函数如 `MBRCONTATNS()` 等来维护数据。**MySQL 的 GIS 支持并不完善，所以大部分人都不会使用这个特性。**

### 全文索引
**全文索引是一种特殊类型的索引，它查找的是文本中的关键字，而不是直接比较索引中的值。**它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的 `WHERE` 条件匹配。

在相同的列上同时创建全文索引和基于 B-Tree 索引不会有冲突。全文索引适用于 `MATCH AGAINST` 操作，而不是普通的 `WHERE` 条件操作。

### 其它索引类别
还有很多第三方的存储引擎使用不同类型的数据结构来存储索引。

---

## 高性能的索引策略

### 独立的列

### 前缀索引和索引选择性

### 多列索引

### 选择合适的索引列顺序

### 聚簇索引

### 覆盖索引

### 使用索引扫描来做排序

### 压缩（前缀压缩）索引

### 冗余和重复索引

### 未使用的索引

### 索引和锁

---

## 总结
<!--
B+Tree数据结构
InnoDB、MyISAM的B+Tree实现
MySQL使用索引
索引的选择性和索引前缀
主键auto_increment
-->
